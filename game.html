<html>
	<head>
		<title>My first Three.js app</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
	
		<!-- JavaScript Inputs. -->
		<script src="js/three.min.js"></script> <!-- three.js  rendering -->
		<script src="js/KeyboardState.js"></script> <!-- three.js  rendering -->
		
		<script language="javascript" type="text/javascript" src="src/Geometry_Manager.js"></script>
		<script language="javascript" type="text/javascript" src="src/World.js"></script>
		
	
		<script>
		
			Math.degrees = function(rad)
			{
				return rad*(180/Math.PI);
			}
 
			Math.radians = function(deg)
			{
				return deg * (Math.PI/180);
			}
		
		
			var scene  = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			camera.position.z = 10;//5;
			camera.position.y = -7;
			camera.lookAt(new THREE.Vector3(0, 5, 0));
			
			
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			
			var Geometries = new Geometry_Manager();
						
			//var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
			
			var mat_terrain = 
				new THREE.MeshLambertMaterial(
				{
					color: 0xFF0000,
					transparent: true,
					opacity: .5
				});
			
			// Sky Box code.
			var url	= "images/test.png";
			var url = "http://findicons.com/files/icons/963/very_emotional_emoticons/64/64_17.png";
			var urls = [url, url,
						url, url,
						url, url];

			THREE.ImageUtils.crossOrigin = '';
			var cubemap = THREE.ImageUtils.loadTextureCube(urls); // load textures
			cubemap.format = THREE.RGBFormat;

			var shader = THREE.ShaderLib['cube']; // init cube shader from built-in lib
			shader.uniforms['tCube'].value = cubemap; // apply textures to shader

			// create shader material
			var skyBoxMaterial = new THREE.ShaderMaterial( {
			  fragmentShader: shader.fragmentShader,
			  vertexShader: shader.vertexShader,
			  uniforms: shader.uniforms,
			  depthWrite: false,
			  side: THREE.BackSide
			});

			// create skybox mesh
			var skybox = new THREE.Mesh(
			  new THREE.CubeGeometry(1000, 1000, 1000),
			  skyBoxMaterial
			);

			scene.add(skybox);
						
						
					
			// End of skybox code.
				
			mat_terrain.vertexColors = THREE.FaceColors;
			
			//*/
			var terrain_mesh = new THREE.Mesh( Geometries.geometry, mat_terrain );
			scene.add( terrain_mesh );
			
			var geometry = new THREE.SphereGeometry( 1, 32, 32 );
			var mat_player = new THREE.MeshLambertMaterial( {color: 0x00ff00} );
						
						
			var player_sphere = new THREE.Mesh( geometry, mat_player);
			scene.add( player_sphere );
			
			
			// White directional light at half intensity shining from the top.

			// Lights

			var ambient = new THREE.AmbientLight( 0x101010 );
			scene.add( ambient );
			

			// create a point light
			var pointLight =
			  new THREE.PointLight(0xFFFFFF);

			// set its position
			pointLight.position.x = 0;
			pointLight.position.y = 0;
			pointLight.position.z = 10;

			// add to the scene
			scene.add(pointLight);
			

			
			var world = new World();

			// Keeps track of Keyboard input.
			var keyboard = new KeyboardState();
			
			var player_x = 0;
			var player_y = 0;
			
			var camera_x = 0;
			var camera_y = 0;
			var camera_z = 0;
			
			var camera_looseness = 20;
			
			var use_tangent_camera = false;
			
			/* Displaying Text. */
			var text2 = document.createElement('div');
			text2.style.position = 'absolute';
			//text2.style.zIndex = 1;    // if you still don't see the label, try uncommenting this
			text2.style.width = window.innerWidth/4;
			text2.style.height = 40;
			text2.style.backgroundColor = "white";
			text2.innerHTML = "";
			text2.style.top = window.innerHeight - 40  + 'px';
			text2.style.left = 0 + 'px';
			document.body.appendChild(text2);
			
			
			var render = function () {
				requestAnimationFrame( render );
				
				keyboard.update();
				world.update();
				
				var V = Geometries.geometry.vertices;
				var len = V.length;
				for(var i = 0; i < len; i++)
				{
					var pos = world.position(V[i].original_x + player_x,
											 V[i].original_y + player_y);

					V[i].x = pos.x - player_x;
					V[i].y = pos.y - player_y;
					V[i].z = pos.z;
				}
															
				Geometries.geometry.computeFaceNormals();
				Geometries.geometry.computeVertexNormals();
				
				
				var pos = world.position(player_x, player_y);
				player_sphere.position.x = pos.x - player_x;
				player_sphere.position.y = pos.y - player_y;
				player_sphere.position.z = pos.z;

				var target_x;
				var target_y;
				var target_z;
				
				if(use_tangent_camera){
				
				// Compute the x and y direction vectors that span the space of the tangent plane.
				var x_dir = world.position(player_x + .01, player_y);
				x_dir = x_dir.sub(pos);
				x_dir.normalize();

				var y_dir = world.position(player_x, player_y + .01);
				y_dir = y_dir.sub(pos);
				y_dir.normalize();
								
				// Add the tangent vector to the player sphere.
				//player_sphere.position = player_sphere.position.add(vec);
				
				// Compute the angled camera offset in the tangent plane to the surface.
				var world_dir = world.forward_direction();
				var dx = x_dir.x*world_dir.x + y_dir.x*world_dir.y;
				var dy = x_dir.y*world_dir.x + y_dir.y*world_dir.y;
				var dz = x_dir.z*world_dir.x + y_dir.z*world_dir.y;
				
				var tangent  = world.tangent (player_x, player_y);
				var target_x = player_sphere.position.x + tangent.x*14 - 15*dx;// - world_dir.x;
				var target_y = player_sphere.position.y + tangent.y*14 - 15*dy;// - world_dir.y;
				var target_z = player_sphere.position.z + tangent.z*14 - 15*dz;
				camera.up.set( tangent.x, tangent.y, tangent.z );
				
				}
				else // Normal z up camera.
				{
					var target_x = player_sphere.position.x;
					var target_y = player_sphere.position.y;
					var target_z = camera.position.z;
					
					camera.up.set( 0, 1, 0);
				}
				
				camera_x = (target_x + camera_looseness*camera_x) / (camera_looseness + 1);
				camera_y = (target_y + camera_looseness*camera_y) / (camera_looseness + 1);
				camera_z = (target_z + camera_looseness*camera_z) / (camera_looseness + 1);


				camera.position.x = camera_x;
				camera.position.y = camera_y;
				camera.position.z = camera_z;

				
				camera.lookAt(new THREE.Vector3(player_sphere.position.x, player_sphere.position.y, player_sphere.position.z));


				//player_sphere

				//console.log(Math.cos(time));
				//terrain_mesh.rotation.z +=.01;

				// Changes to Vertex positions.
				Geometries.geometry.verticesNeedUpdate = true;

				// Changes to Vertex normals.
				Geometries.geometry.normalsNeedUpdate = true;

				Geometries.geometry.colosNeedUpdate = true;



				renderer.render(scene, camera);

			};

			render();
		</script>
	</body>
</html>